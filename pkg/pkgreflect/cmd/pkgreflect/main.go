/*
Problem: Go reflection does not support enumerating types, variables and functions of packages.

pkgreflect generates a file named pkgreflect.go in every parsed package directory.
This file contains the following maps of exported names to reflection types/values:

	var Types = map[string]reflect.Type{ ... }
	var Functions = map[string]reflect.Value{ ... }
	var Variables = map[string]reflect.Value{ ... }

Command line usage:

	pkgreflect --help
	pkgreflect [-notypes][-nofuncs][-novars][-unexported][-norecurs][-gofile=filename.go] [DIR_NAME]

If -norecurs is not set, then pkgreflect traverses recursively into sub-directories.
If no DIR_NAME is given, then the current directory is used as root.
*/
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var (
	notypes    bool
	nofuncs    bool
	novars     bool
	noconsts   bool
	unexported bool
	norecurs   bool
	stdout     bool
	gofile     string
	notests    bool
	name       string
)

func main() {
	flag.BoolVar(&notypes, "notypes", false, "Don't list package types")
	flag.BoolVar(&nofuncs, "nofuncs", false, "Don't list package functions")
	flag.BoolVar(&novars, "novars", false, "Don't list package variables")
	flag.BoolVar(&noconsts, "noconsts", false, "Don't list package consts")
	flag.BoolVar(&unexported, "unexported", false, "Also list unexported names")
	flag.BoolVar(&norecurs, "norecurs", true, "Don't parse sub-directories resursively")
	flag.StringVar(&gofile, "gofile", "pkgreflect.go", "Name of the generated .go file")
	flag.BoolVar(&stdout, "stdout", false, "Write to stdout.")
	flag.BoolVar(&notests, "notests", true, "Don't list test related code")
	flag.StringVar(&name, "name", "", "full name to give package")
	flag.Parse()

	if len(flag.Args()) > 0 {
		for _, dir := range flag.Args() {
			parseDir(dir)
		}
	} else {
		parseDir(".")
	}
}

func typeName(x ast.Expr) string {
	for {
		switch sv := x.(type) {
		case *ast.StarExpr:
			x = sv.X
		case *ast.Ident:
			return sv.Name
		case *ast.SelectorExpr:
			return typeName(sv.X) + "." + sv.Sel.Name
		case *ast.ArrayType:
			return "[]" + typeName(sv.Elt)
		case *ast.InterfaceType:
			if len(sv.Methods.List) == 0 {
				return "any"
			}

			return "interface"
		default:
			return "Unknown"
		}
	}
}

func parseDir(dir string) {
	dirFile, err := os.Open(dir)
	if err != nil {
		panic(err)
	}
	defer dirFile.Close()
	info, err := dirFile.Stat()
	if err != nil {
		panic(err)
	}
	if !info.IsDir() {
		panic("Path is not a directory: " + dir)
	}

	pkgs, err := parser.ParseDir(token.NewFileSet(), dir, filter, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	for _, pkg := range pkgs {
		if pkg.Name == "main" || strings.HasSuffix(pkg.Name, "_test") {
			continue
		}

		if name == "" {
			name = pkg.Name
		}

		var buf bytes.Buffer

		fmt.Fprintln(&buf, "// Code generated by github.com/lab47/lace/pkg/pkgreflect DO NOT EDIT.")
		fmt.Fprintln(&buf, "package", "reflect")
		fmt.Fprintln(&buf, "")
		fmt.Fprintln(&buf, `import "reflect"`)
		fmt.Fprintln(&buf, `import "github.com/lab47/lace/pkg/pkgreflect"`)
		fmt.Fprintf(&buf, "import . \"%s\"\n", name)
		fmt.Fprintln(&buf, "")
		fmt.Fprintln(&buf, "func init() {")

		for _, f := range pkg.Files {
			for _, d := range f.Scope.Objects {
				if ts, ok := d.Decl.(*ast.TypeSpec); ok {
					if !ast.IsExported(ts.Name.Name) {
						continue
					}
					fmt.Fprintf(&buf, "%s_methods := map[string]pkgreflect.Func{}\n", ts.Name.Name)
					/*
						if fn.Recv != nil && len(fn.Recv.List) == 1 {
							rt := typeName(fn.Recv.List[0].Type)
							if _, ok := seen[rt]; !ok {
								seen[rt] = struct{}{}
							}
						}
					*/
				}
			}
		}

		for _, f := range pkg.Files {
			for _, d := range f.Decls {
				if fn, ok := d.(*ast.FuncDecl); ok {
					if !ast.IsExported(fn.Name.Name) {
						continue
					}
					if fn.Recv != nil && len(fn.Recv.List) == 1 {
						rt := typeName(fn.Recv.List[0].Type)
						if !ast.IsExported(rt) {
							continue
						}

						var args []string
						for _, f := range fn.Type.Params.List {
							for _, n := range f.Names {
								args = append(args, fmt.Sprintf("{Name: \"%s\", Tag: \"%s\"}", n.Name, typeName(f.Type)))
							}
						}

						tag := "any"

						if fn.Type.Results != nil && len(fn.Type.Results.List) == 1 {
							tag = typeName(fn.Type.Results.List[0].Type)
						}

						arity := strings.Join(args, `,`)
						fmt.Fprintf(&buf, "%s_methods[\"%s\"] = pkgreflect.Func{Args: []pkgreflect.Arg{%s}, Tag: \"%s\", Doc: `%s`}\n", rt, fn.Name.Name, arity, tag, strings.TrimSpace(fn.Doc.Text()))
					}
				}
			}
		}

		fmt.Fprintf(&buf, "pkgreflect.AddPackage(\"%s\", &pkgreflect.Package{\n", name)

		// Types
		if !notypes {
			fmt.Fprintln(&buf, "Types: map[string]pkgreflect.Type{")
			print(&buf, pkg, ast.Typ, "\t\"%s\": {Doc: `%s`, Value: reflect.TypeOf((*%s)(nil)).Elem(), Methods: %[1]s_methods},\n")
			fmt.Fprintln(&buf, "},")
			fmt.Fprintln(&buf, "")
		}

		// Functions
		if !nofuncs {
			fmt.Fprintln(&buf, "Functions: map[string]pkgreflect.FuncValue{")
			fnprint(&buf, pkg, ast.Fun)
			fmt.Fprintln(&buf, "},")
			fmt.Fprintln(&buf, "")
		}

		if !novars {
			// Addresses of variables
			fmt.Fprintln(&buf, "Variables: map[string]pkgreflect.Value{")
			print(&buf, pkg, ast.Var, "\t\"%s\": {Doc: `%s`, Value: reflect.ValueOf(&%s)},\n")
			fmt.Fprintln(&buf, "},")
			fmt.Fprintln(&buf, "")
		}

		if !noconsts {
			// Addresses of consts
			fmt.Fprintln(&buf, "Consts: map[string]pkgreflect.Value{")
			print(&buf, pkg, ast.Con, "\t\"%s\": {Doc: `%s`, Value: reflect.ValueOf(%s)},\n")
			fmt.Fprintln(&buf, "},")
			fmt.Fprintln(&buf, "")
		}

		fmt.Fprintln(&buf, "})")
		fmt.Fprintln(&buf, "}")

		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			formatted = buf.Bytes()
		}

		if stdout {
			os.Stdout.Write(formatted)
		} else {
			filename := filepath.Join(dir, gofile)
			oldFileData, _ := os.ReadFile(filename)
			if !bytes.Equal(formatted, oldFileData) {
				err = os.WriteFile(filename, formatted, 0660)
				if err != nil {
					panic(err)
				}
			}
		}
	}

	if !norecurs {
		dirs, err := dirFile.Readdir(-1)
		if err != nil {
			panic(err)
		}
		for _, info := range dirs {
			if info.IsDir() {
				parseDir(filepath.Join(dir, info.Name()))
			}
		}
	}
}

func getDoc(object *ast.Object) string {
	switch v := object.Decl.(type) {
	case *ast.ValueSpec:
		return v.Doc.Text()
	case *ast.FuncDecl:
		return v.Doc.Text()
	case *ast.TypeSpec:
		return v.Doc.Text()
	default:
		return ""
	}
}

func print(w io.Writer, pkg *ast.Package, kind ast.ObjKind, format string) {
	type ent struct {
		name, doc string
	}

	names := []ent{}
	for _, f := range pkg.Files {
		for name, object := range f.Scope.Objects {
			if object.Kind == kind && (unexported || ast.IsExported(name)) {
				names = append(names, ent{name, strings.TrimSpace(getDoc(object))})
			}
		}
	}

	sort.Slice(names, func(i, j int) bool {
		return names[i].name < names[j].name
	})

	for _, name := range names {
		fmt.Fprintf(w, format, name.name, name.doc, name.name)
	}
}

func fnprint(w io.Writer, pkg *ast.Package, kind ast.ObjKind) {
	var fns []string

	// fnprint(&buf, pkg, ast.Fun, "\t\"%s\": {Doc: `%s`, Value: reflect.ValueOf(%s)},\n")

	for _, f := range pkg.Files {
		for name, object := range f.Scope.Objects {
			if object.Kind == kind && (unexported || ast.IsExported(name)) {
				fn := object.Decl.(*ast.FuncDecl)
				var args []string
				for _, f := range fn.Type.Params.List {
					for _, n := range f.Names {
						args = append(args, fmt.Sprintf("{Name: \"%s\", Tag: \"%s\"}", n.Name, typeName(f.Type)))
					}
				}

				rt := "any"

				if fn.Type.Results != nil && len(fn.Type.Results.List) == 1 {
					rt = typeName(fn.Type.Results.List[0].Type)
				}

				arity := strings.Join(args, `,`)
				fns = append(fns,
					fmt.Sprintf("\t\"%s\": {Doc: `%s`, Args: []pkgreflect.Arg{%s}, Tag: \"%s\", Value: reflect.ValueOf(%[1]s)},\n", fn.Name.Name, strings.TrimSpace(fn.Doc.Text()), arity, rt),
				)
			}
		}
	}

	sort.Strings(fns)

	for _, f := range fns {
		fmt.Fprintln(w, f)
	}
}

func filter(info os.FileInfo) bool {

	name := info.Name()

	if info.IsDir() {
		return false
	}

	if name == gofile {
		return false
	}

	if filepath.Ext(name) != ".go" {
		return false
	}

	if strings.HasSuffix(name, "_test.go") && notests {
		return false
	}

	return true

}
