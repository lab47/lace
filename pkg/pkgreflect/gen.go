package pkgreflect

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/davecgh/go-spew/spew"
)

func typeList(fl *ast.FieldList) string {
	var ret []string

	for _, e := range fl.List {
		ret = append(ret, typeName(e.Type))
	}

	return strings.Join(ret, ", ")
}

func Generate(name string, base, output string) error {
	pkg, err := build.Import(name, base, build.ImportComment)
	if err != nil {
		return err
	}

	var files []*ast.File

	ts := token.NewFileSet()
	sort.Strings(pkg.GoFiles)

	for _, path := range pkg.GoFiles {
		f, err := parser.ParseFile(ts, filepath.Join(pkg.Dir, path), nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		files = append(files, f)
	}

	info := types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}
	var conf types.Config
	conf.Importer = importer.Default()
	tpkg, err := conf.Check("p", ts, files, &info)
	if err != nil {
		log.Fatal(err)
	}

	spew.Dump(tpkg.Name())

	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by github.com/lab47/lace/pkg/pkgreflect DO NOT EDIT.")
	fmt.Fprintln(&buf, "package", "reflect")
	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, `import "reflect"`)
	fmt.Fprintln(&buf, `import "github.com/lab47/lace/pkg/pkgreflect"`)
	fmt.Fprintf(&buf, "import p \"%s\"\n", pkg.ImportPath)
	fmt.Fprintln(&buf, "")

	var (
		typesForMethods []string
		synthStruct     []string
	)

	for _, f := range files {
		var keys []string
		for k := range f.Scope.Objects {
			keys = append(keys, k)
		}

		sort.Strings(keys)

		for _, k := range keys {
			d := f.Scope.Objects[k]
			if ts, ok := d.Decl.(*ast.TypeSpec); ok {
				if !ast.IsExported(ts.Name.Name) {
					continue
				}
				typesForMethods = append(typesForMethods, ts.Name.Name)

				if it, ok := ts.Type.(*ast.InterfaceType); ok {
					itt := info.Types[it].Type.(*types.Interface)

					fmt.Fprintf(&buf, "type %sImpl struct {\n", ts.Name.Name)
					synthStruct = append(synthStruct, ts.Name.Name+"Impl")

					for i := 0; i < itt.NumMethods(); i++ {
						fn := itt.Method(i)
						sig := fn.Type().(*types.Signature)
						fmt.Fprintf(&buf, "  %sFn func%s %s\n", fn.Name(), sig.Params().String(), sig.Results().String())
					}
					fmt.Fprintf(&buf, "}\n")

					for i := 0; i < itt.NumMethods(); i++ {
						fn := itt.Method(i)
						sig := fn.Type().(*types.Signature)

						var args []string
						var cs []string

						for j := 0; j < sig.Params().Len(); j++ {
							e := sig.Params().At(j)
							args = append(args, fmt.Sprintf("a%d %s", j, e.Type().String()))
							cs = append(cs, fmt.Sprintf("a%d", j))
						}

						fmt.Fprintf(&buf, "func (s *%sImpl) %s(%s) %s {\n", ts.Name.Name, fn.Name(), strings.Join(args, ", "), sig.Results().String())
						if sig.Results().Len() == 0 {
							fmt.Fprintf(&buf, "s.%sFn(%s)\n", fn.Name(), strings.Join(cs, ", "))
						} else {
							fmt.Fprintf(&buf, "return s.%sFn(%s)\n", fn.Name(), strings.Join(cs, ", "))
						}
						fmt.Fprintln(&buf, "}")
					}
				}
			}
		}
	}

	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, "func init() {")

	for _, t := range typesForMethods {
		fmt.Fprintf(&buf, "%s_methods := map[string]pkgreflect.Func{}\n", t)
	}

	for _, f := range files {
		for _, d := range f.Decls {
			if fn, ok := d.(*ast.FuncDecl); ok {
				if !ast.IsExported(fn.Name.Name) {
					continue
				}
				if fn.Recv != nil && len(fn.Recv.List) == 1 {
					rt := typeName(fn.Recv.List[0].Type)
					if !ast.IsExported(rt) {
						continue
					}

					var args []string
					for _, f := range fn.Type.Params.List {
						for _, n := range f.Names {
							args = append(args, fmt.Sprintf("{Name: \"%s\", Tag: \"%s\"}", n.Name, typeName(f.Type)))
						}
					}

					tag := "any"

					if fn.Type.Results != nil && len(fn.Type.Results.List) == 1 {
						tag = typeName(fn.Type.Results.List[0].Type)
					}

					arity := strings.Join(args, `,`)
					fmt.Fprintf(&buf, "%s_methods[%q] = pkgreflect.Func{Args: []pkgreflect.Arg{%s}, Tag: \"%s\", Doc: %q}\n", rt, fn.Name.Name, arity, tag, strings.TrimSpace(fn.Doc.Text()))
				}
			}
		}
	}

	fmt.Fprintf(&buf, "pkgreflect.AddPackage(%q, &pkgreflect.Package{\n", name)
	fmt.Fprintf(&buf, "Doc: %q,\n", pkg.Doc)

	// Types
	fmt.Fprintln(&buf, "Types: map[string]pkgreflect.Type{")
	print(&buf, files, ast.Typ, "\t%q: {Doc: %q, Value: reflect.TypeOf((*p.%s)(nil)).Elem(), Methods: %[1]s_methods},\n")
	for _, ss := range synthStruct {
		fmt.Fprintf(&buf, "\t%q: {Doc: `Struct version of interface %s for implementation`, Value: reflect.TypeFor[%[1]s]()},\n", ss, ss[:len(ss)-4])
	}
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	// Functions
	fmt.Fprintln(&buf, "Functions: map[string]pkgreflect.FuncValue{")
	fnprint(&buf, files, ast.Fun)
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	// Addresses of variables
	fmt.Fprintln(&buf, "Variables: map[string]pkgreflect.Value{")
	print(&buf, files, ast.Var, "\t%q: {Doc: %q, Value: reflect.ValueOf(&p.%s)},\n")
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	// Addresses of consts
	fmt.Fprintln(&buf, "Consts: map[string]pkgreflect.Value{")
	print(&buf, files, ast.Con, "\t%q: {Doc: %q, Value: reflect.ValueOf(p.%s)},\n")
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	fmt.Fprintln(&buf, "})")
	fmt.Fprintln(&buf, "}")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		os.Stderr.Write(buf.Bytes())
		return err
	}

	if output == "-" {
		os.Stdout.Write(formatted)
	} else {
		filename := filepath.Join(output)
		oldFileData, _ := os.ReadFile(filename)
		if !bytes.Equal(formatted, oldFileData) {
			err = os.WriteFile(filename, formatted, 0660)
			if err != nil {
				panic(err)
			}
		}
	}

	return nil
}

func typeName(x ast.Expr) string {
	for {
		switch sv := x.(type) {
		case *ast.StarExpr:
			x = sv.X
		case *ast.Ident:
			return sv.Name
		case *ast.SelectorExpr:
			return typeName(sv.X) + "." + sv.Sel.Name
		case *ast.ArrayType:
			return "[]" + typeName(sv.Elt)
		case *ast.InterfaceType:
			if len(sv.Methods.List) == 0 {
				return "any"
			}

			return "interface"
		default:
			return "Unknown"
		}
	}
}

func getDoc(object *ast.Object) string {
	switch v := object.Decl.(type) {
	case *ast.ValueSpec:
		return v.Doc.Text()
	case *ast.FuncDecl:
		return v.Doc.Text()
	case *ast.TypeSpec:
		return v.Doc.Text()
	default:
		return ""
	}
}

func print(w io.Writer, files []*ast.File, kind ast.ObjKind, format string) {
	type ent struct {
		name, doc string
	}

	names := []ent{}
	for _, f := range files {
		for name, object := range f.Scope.Objects {
			if object.Kind == kind && ast.IsExported(name) {
				names = append(names, ent{name, strings.TrimSpace(getDoc(object))})
			}
		}
	}

	sort.Slice(names, func(i, j int) bool {
		return names[i].name < names[j].name
	})

	for _, name := range names {
		fmt.Fprintf(w, format, name.name, name.doc, name.name)
	}
}

func fnprint(w io.Writer, files []*ast.File, kind ast.ObjKind) {
	var fns []string

	for _, f := range files {
		for name, object := range f.Scope.Objects {
			if object.Kind == kind && ast.IsExported(name) {
				fn := object.Decl.(*ast.FuncDecl)
				var args []string
				for _, f := range fn.Type.Params.List {
					for _, n := range f.Names {
						args = append(args, fmt.Sprintf("{Name: \"%s\", Tag: \"%s\"}", n.Name, typeName(f.Type)))
					}
				}

				rt := "any"

				if fn.Type.Results != nil && len(fn.Type.Results.List) == 1 {
					rt = typeName(fn.Type.Results.List[0].Type)
				}

				arity := strings.Join(args, `,`)
				fns = append(fns,
					fmt.Sprintf("\t\"%s\": {Doc: %q, Args: []pkgreflect.Arg{%s}, Tag: \"%s\", Value: reflect.ValueOf(p.%[1]s)},\n", fn.Name.Name, strings.TrimSpace(fn.Doc.Text()), arity, rt),
				)
			}
		}
	}

	sort.Strings(fns)

	for _, f := range fns {
		fmt.Fprintln(w, f)
	}
}
