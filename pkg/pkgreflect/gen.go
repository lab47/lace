package pkgreflect

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func Generate(name string, base, output string) error {
	pkg, err := build.Import(name, base, build.ImportComment)
	if err != nil {
		return err
	}

	var files []*ast.File

	ts := token.NewFileSet()
	sort.Strings(pkg.GoFiles)

	for _, path := range pkg.GoFiles {
		f, err := parser.ParseFile(ts, filepath.Join(pkg.Dir, path), nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		files = append(files, f)
	}

	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by github.com/lab47/lace/pkg/pkgreflect DO NOT EDIT.")
	fmt.Fprintln(&buf, "package", "reflect")
	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, `import "reflect"`)
	fmt.Fprintln(&buf, `import "github.com/lab47/lace/pkg/pkgreflect"`)
	fmt.Fprintf(&buf, "import . \"%s\"\n", pkg.ImportPath)
	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, "func init() {")

	for _, f := range files {
		var keys []string
		for k := range f.Scope.Objects {
			keys = append(keys, k)
		}

		sort.Strings(keys)

		for _, k := range keys {
			d := f.Scope.Objects[k]
			if ts, ok := d.Decl.(*ast.TypeSpec); ok {
				if !ast.IsExported(ts.Name.Name) {
					continue
				}
				fmt.Fprintf(&buf, "%s_methods := map[string]pkgreflect.Func{}\n", ts.Name.Name)
				/*
					if fn.Recv != nil && len(fn.Recv.List) == 1 {
						rt := typeName(fn.Recv.List[0].Type)
						if _, ok := seen[rt]; !ok {
							seen[rt] = struct{}{}
						}
					}
				*/
			}
		}
	}

	for _, f := range files {
		for _, d := range f.Decls {
			if fn, ok := d.(*ast.FuncDecl); ok {
				if !ast.IsExported(fn.Name.Name) {
					continue
				}
				if fn.Recv != nil && len(fn.Recv.List) == 1 {
					rt := typeName(fn.Recv.List[0].Type)
					if !ast.IsExported(rt) {
						continue
					}

					var args []string
					for _, f := range fn.Type.Params.List {
						for _, n := range f.Names {
							args = append(args, fmt.Sprintf("{Name: \"%s\", Tag: \"%s\"}", n.Name, typeName(f.Type)))
						}
					}

					tag := "any"

					if fn.Type.Results != nil && len(fn.Type.Results.List) == 1 {
						tag = typeName(fn.Type.Results.List[0].Type)
					}

					arity := strings.Join(args, `,`)
					fmt.Fprintf(&buf, "%s_methods[%q] = pkgreflect.Func{Args: []pkgreflect.Arg{%s}, Tag: \"%s\", Doc: %q}\n", rt, fn.Name.Name, arity, tag, strings.TrimSpace(fn.Doc.Text()))
				}
			}
		}
	}

	fmt.Fprintf(&buf, "pkgreflect.AddPackage(%q, &pkgreflect.Package{\n", name)
	fmt.Fprintf(&buf, "Doc: %q,\n", pkg.Doc)

	// Types
	fmt.Fprintln(&buf, "Types: map[string]pkgreflect.Type{")
	print(&buf, files, ast.Typ, "\t%q: {Doc: %q, Value: reflect.TypeOf((*%s)(nil)).Elem(), Methods: %[1]s_methods},\n")
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	// Functions
	fmt.Fprintln(&buf, "Functions: map[string]pkgreflect.FuncValue{")
	fnprint(&buf, files, ast.Fun)
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	// Addresses of variables
	fmt.Fprintln(&buf, "Variables: map[string]pkgreflect.Value{")
	print(&buf, files, ast.Var, "\t%q: {Doc: %q, Value: reflect.ValueOf(&%s)},\n")
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	// Addresses of consts
	fmt.Fprintln(&buf, "Consts: map[string]pkgreflect.Value{")
	print(&buf, files, ast.Con, "\t%q: {Doc: %q, Value: reflect.ValueOf(%s)},\n")
	fmt.Fprintln(&buf, "},")
	fmt.Fprintln(&buf, "")

	fmt.Fprintln(&buf, "})")
	fmt.Fprintln(&buf, "}")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	if output == "-" {
		os.Stdout.Write(formatted)
	} else {
		filename := filepath.Join(output)
		oldFileData, _ := os.ReadFile(filename)
		if !bytes.Equal(formatted, oldFileData) {
			err = os.WriteFile(filename, formatted, 0660)
			if err != nil {
				panic(err)
			}
		}
	}

	return nil
}

func typeName(x ast.Expr) string {
	for {
		switch sv := x.(type) {
		case *ast.StarExpr:
			x = sv.X
		case *ast.Ident:
			return sv.Name
		case *ast.SelectorExpr:
			return typeName(sv.X) + "." + sv.Sel.Name
		case *ast.ArrayType:
			return "[]" + typeName(sv.Elt)
		case *ast.InterfaceType:
			if len(sv.Methods.List) == 0 {
				return "any"
			}

			return "interface"
		default:
			return "Unknown"
		}
	}
}

func getDoc(object *ast.Object) string {
	switch v := object.Decl.(type) {
	case *ast.ValueSpec:
		return v.Doc.Text()
	case *ast.FuncDecl:
		return v.Doc.Text()
	case *ast.TypeSpec:
		return v.Doc.Text()
	default:
		return ""
	}
}

func print(w io.Writer, files []*ast.File, kind ast.ObjKind, format string) {
	type ent struct {
		name, doc string
	}

	names := []ent{}
	for _, f := range files {
		for name, object := range f.Scope.Objects {
			if object.Kind == kind && ast.IsExported(name) {
				names = append(names, ent{name, strings.TrimSpace(getDoc(object))})
			}
		}
	}

	sort.Slice(names, func(i, j int) bool {
		return names[i].name < names[j].name
	})

	for _, name := range names {
		fmt.Fprintf(w, format, name.name, name.doc, name.name)
	}
}

func fnprint(w io.Writer, files []*ast.File, kind ast.ObjKind) {
	var fns []string

	// fnprint(&buf, pkg, ast.Fun, "\t\"%s\": {Doc: `%s`, Value: reflect.ValueOf(%s)},\n")

	for _, f := range files {
		for name, object := range f.Scope.Objects {
			if object.Kind == kind && ast.IsExported(name) {
				fn := object.Decl.(*ast.FuncDecl)
				var args []string
				for _, f := range fn.Type.Params.List {
					for _, n := range f.Names {
						args = append(args, fmt.Sprintf("{Name: \"%s\", Tag: \"%s\"}", n.Name, typeName(f.Type)))
					}
				}

				rt := "any"

				if fn.Type.Results != nil && len(fn.Type.Results.List) == 1 {
					rt = typeName(fn.Type.Results.List[0].Type)
				}

				arity := strings.Join(args, `,`)
				fns = append(fns,
					fmt.Sprintf("\t\"%s\": {Doc: %q, Args: []pkgreflect.Arg{%s}, Tag: \"%s\", Value: reflect.ValueOf(%[1]s)},\n", fn.Name.Name, strings.TrimSpace(fn.Doc.Text()), arity, rt),
				)
			}
		}
	}

	sort.Strings(fns)

	for _, f := range fns {
		fmt.Fprintln(w, f)
	}
}
