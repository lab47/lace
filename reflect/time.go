// Code generated by github.com/lab47/lace/pkg/pkgreflect DO NOT EDIT.
package reflect

import "reflect"
import "github.com/lab47/lace/pkg/pkgreflect"
import . "time"

func init() {
	Location_methods := map[string]pkgreflect.Func{}
	Timer_methods := map[string]pkgreflect.Func{}
	ParseError_methods := map[string]pkgreflect.Func{}
	Ticker_methods := map[string]pkgreflect.Func{}
	Month_methods := map[string]pkgreflect.Func{}
	Weekday_methods := map[string]pkgreflect.Func{}
	Time_methods := map[string]pkgreflect.Func{}
	Duration_methods := map[string]pkgreflect.Func{}
	Ticker_methods["Stop"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `Stop turns off a ticker. After Stop, no more ticks will be sent.
Stop does not close the channel, to prevent a concurrent goroutine
reading from the channel from seeing an erroneous "tick".`}
	Ticker_methods["Reset"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "any", Doc: `Reset stops a ticker and resets its period to the specified duration.
The next tick will arrive after the new period elapses. The duration d
must be greater than zero; if not, Reset will panic.`}
	Time_methods["After"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "u", Tag: "Time"}}, Tag: "bool", Doc: `After reports whether the time instant t is after u.`}
	Time_methods["Before"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "u", Tag: "Time"}}, Tag: "bool", Doc: `Before reports whether the time instant t is before u.`}
	Time_methods["Compare"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "u", Tag: "Time"}}, Tag: "int", Doc: `Compare compares the time instant t with u. If t is before u, it returns -1;
if t is after u, it returns +1; if they're the same, it returns 0.`}
	Time_methods["Equal"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "u", Tag: "Time"}}, Tag: "bool", Doc: `Equal reports whether t and u represent the same time instant.
Two times can be equal even if they are in different locations.
For example, 6:00 +0200 and 4:00 UTC are Equal.
See the documentation on the Time type for the pitfalls of using == with
Time values; most code should use Equal instead.`}
	Month_methods["String"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `String returns the English name of the month ("January", "February", ...).`}
	Weekday_methods["String"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `String returns the English name of the day ("Sunday", "Monday", ...).`}
	Time_methods["IsZero"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "bool", Doc: `IsZero reports whether t represents the zero time instant,
January 1, year 1, 00:00:00 UTC.`}
	Time_methods["Date"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `Date returns the year, month, and day in which t occurs.`}
	Time_methods["Year"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Year returns the year in which t occurs.`}
	Time_methods["Month"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Month", Doc: `Month returns the month of the year specified by t.`}
	Time_methods["Day"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Day returns the day of the month specified by t.`}
	Time_methods["Weekday"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Weekday", Doc: `Weekday returns the day of the week specified by t.`}
	Time_methods["ISOWeek"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `ISOWeek returns the ISO 8601 year and week number in which t occurs.
Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
of year n+1.`}
	Time_methods["Clock"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Clock returns the hour, minute, and second within the day specified by t.`}
	Time_methods["Hour"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Hour returns the hour within the day specified by t, in the range [0, 23].`}
	Time_methods["Minute"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Minute returns the minute offset within the hour specified by t, in the range [0, 59].`}
	Time_methods["Second"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Second returns the second offset within the minute specified by t, in the range [0, 59].`}
	Time_methods["Nanosecond"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Nanosecond returns the nanosecond offset within the second specified by t,
in the range [0, 999999999].`}
	Time_methods["YearDay"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
and [1,366] in leap years.`}
	Duration_methods["String"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `String returns a string representing the duration in the form "72h3m0.5s".
Leading zero units are omitted. As a special case, durations less than one
second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
that the leading digit is non-zero. The zero duration formats as 0s.`}
	Duration_methods["Nanoseconds"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `Nanoseconds returns the duration as an integer nanosecond count.`}
	Duration_methods["Microseconds"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `Microseconds returns the duration as an integer microsecond count.`}
	Duration_methods["Milliseconds"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `Milliseconds returns the duration as an integer millisecond count.`}
	Duration_methods["Seconds"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "float64", Doc: `Seconds returns the duration as a floating point number of seconds.`}
	Duration_methods["Minutes"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "float64", Doc: `Minutes returns the duration as a floating point number of minutes.`}
	Duration_methods["Hours"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "float64", Doc: `Hours returns the duration as a floating point number of hours.`}
	Duration_methods["Truncate"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "m", Tag: "Duration"}}, Tag: "Duration", Doc: `Truncate returns the result of rounding d toward zero to a multiple of m.
If m <= 0, Truncate returns d unchanged.`}
	Duration_methods["Round"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "m", Tag: "Duration"}}, Tag: "Duration", Doc: `Round returns the result of rounding d to the nearest multiple of m.
The rounding behavior for halfway values is to round away from zero.
If the result exceeds the maximum (or minimum)
value that can be stored in a Duration,
Round returns the maximum (or minimum) duration.
If m <= 0, Round returns d unchanged.`}
	Duration_methods["Abs"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Duration", Doc: `Abs returns the absolute value of d.
As a special case, math.MinInt64 is converted to math.MaxInt64.`}
	Time_methods["Add"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Time", Doc: `Add returns the time t+d.`}
	Time_methods["Sub"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "u", Tag: "Time"}}, Tag: "Duration", Doc: `Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
value that can be stored in a Duration, the maximum (or minimum) duration
will be returned.
To compute t-d for a duration d, use t.Add(-d).`}
	Time_methods["AddDate"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "years", Tag: "int"}, {Name: "months", Tag: "int"}, {Name: "days", Tag: "int"}}, Tag: "Time", Doc: `AddDate returns the time corresponding to adding the
given number of years, months, and days to t.
For example, AddDate(-1, 2, 3) applied to January 1, 2011
returns March 4, 2010.

Note that dates are fundamentally coupled to timezones, and calendrical
periods like days don't have fixed durations. AddDate uses the Location of
the Time value to determine these durations. That means that the same
AddDate arguments can produce a different shift in absolute time depending on
the base Time value and its Location. For example, AddDate(0, 0, 1) applied
to 12:00 on March 27 always returns 12:00 on March 28. At some locations and
in some years this is a 24 hour shift. In others it's a 23 hour shift due to
daylight savings time transitions.

AddDate normalizes its result in the same way that Date does,
so, for example, adding one month to October 31 yields
December 1, the normalized form for November 31.`}
	Time_methods["UTC"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Time", Doc: `UTC returns t with the location set to UTC.`}
	Time_methods["Local"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Time", Doc: `Local returns t with the location set to local time.`}
	Time_methods["In"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "loc", Tag: "Location"}}, Tag: "Time", Doc: `In returns a copy of t representing the same time instant, but
with the copy's location information set to loc for display
purposes.

In panics if loc is nil.`}
	Time_methods["Location"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Location", Doc: `Location returns the time zone information associated with t.`}
	Time_methods["Zone"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `Zone computes the time zone in effect at time t, returning the abbreviated
name of the zone (such as "CET") and its offset in seconds east of UTC.`}
	Time_methods["ZoneBounds"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "Time", Doc: `ZoneBounds returns the bounds of the time zone in effect at time t.
The zone begins at start and the next zone begins at end.
If the zone begins at the beginning of time, start will be returned as a zero Time.
If the zone goes on forever, end will be returned as a zero Time.
The Location of the returned times will be the same as t.`}
	Time_methods["Unix"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `Unix returns t as a Unix time, the number of seconds elapsed
since January 1, 1970 UTC. The result does not depend on the
location associated with t.
Unix-like operating systems often record time as a 32-bit
count of seconds, but since the method here returns a 64-bit
value it is valid for billions of years into the past or future.`}
	Time_methods["UnixMilli"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in
milliseconds cannot be represented by an int64 (a date more than 292 million
years before or after 1970). The result does not depend on the
location associated with t.`}
	Time_methods["UnixMicro"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `UnixMicro returns t as a Unix time, the number of microseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in
microseconds cannot be represented by an int64 (a date before year -290307 or
after year 294246). The result does not depend on the location associated
with t.`}
	Time_methods["UnixNano"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int64", Doc: `UnixNano returns t as a Unix time, the number of nanoseconds elapsed
since January 1, 1970 UTC. The result is undefined if the Unix time
in nanoseconds cannot be represented by an int64 (a date before the year
1678 or after 2262). Note that this means the result of calling UnixNano
on the zero Time is undefined. The result does not depend on the
location associated with t.`}
	Time_methods["MarshalBinary"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `MarshalBinary implements the encoding.BinaryMarshaler interface.`}
	Time_methods["UnmarshalBinary"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "error", Doc: `UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.`}
	Time_methods["GobEncode"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `GobEncode implements the gob.GobEncoder interface.`}
	Time_methods["GobDecode"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "error", Doc: `GobDecode implements the gob.GobDecoder interface.`}
	Time_methods["MarshalJSON"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `MarshalJSON implements the json.Marshaler interface.
The time is a quoted string in the RFC 3339 format with sub-second precision.
If the timestamp cannot be represented as valid RFC 3339
(e.g., the year is out of range), then an error is reported.`}
	Time_methods["UnmarshalJSON"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "error", Doc: `UnmarshalJSON implements the json.Unmarshaler interface.
The time must be a quoted string in the RFC 3339 format.`}
	Time_methods["MarshalText"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `MarshalText implements the encoding.TextMarshaler interface.
The time is formatted in RFC 3339 format with sub-second precision.
If the timestamp cannot be represented as valid RFC 3339
(e.g., the year is out of range), then an error is reported.`}
	Time_methods["UnmarshalText"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "error", Doc: `UnmarshalText implements the encoding.TextUnmarshaler interface.
The time must be in the RFC 3339 format.`}
	Time_methods["IsDST"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "bool", Doc: `IsDST reports whether the time in the configured location is in Daylight Savings Time.`}
	Time_methods["Truncate"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Time", Doc: `Truncate returns the result of rounding t down to a multiple of d (since the zero time).
If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.

Truncate operates on the time as an absolute duration since the
zero time; it does not operate on the presentation form of the
time. Thus, Truncate(Hour) may return a time with a non-zero
minute, depending on the time's Location.`}
	Time_methods["Round"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Time", Doc: `Round returns the result of rounding t to the nearest multiple of d (since the zero time).
The rounding behavior for halfway values is to round up.
If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.

Round operates on the time as an absolute duration since the
zero time; it does not operate on the presentation form of the
time. Thus, Round(Hour) may return a time with a non-zero
minute, depending on the time's Location.`}
	Time_methods["String"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `String returns the time formatted using the format string

	"2006-01-02 15:04:05.999999999 -0700 MST"

If the time has a monotonic clock reading, the returned string
includes a final field "m=±<value>", where value is the monotonic
clock reading formatted as a decimal number of seconds.

The returned string is meant for debugging; for a stable serialized
representation, use t.MarshalText, t.MarshalBinary, or t.Format
with an explicit format string.`}
	Time_methods["GoString"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `GoString implements fmt.GoStringer and formats t to be printed in Go source
code.`}
	Time_methods["Format"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "layout", Tag: "string"}}, Tag: "string", Doc: `Format returns a textual representation of the time value formatted according
to the layout defined by the argument. See the documentation for the
constant called Layout to see how to represent the layout format.

The executable example for Time.Format demonstrates the working
of the layout string in detail and is a good reference.`}
	Time_methods["AppendFormat"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "b", Tag: "[]byte"}, {Name: "layout", Tag: "string"}}, Tag: "[]byte", Doc: `AppendFormat is like Format but appends the textual
representation to b and returns the extended buffer.`}
	ParseError_methods["Error"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `Error returns the string representation of a ParseError.`}
	Location_methods["String"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `String returns a descriptive name for the time zone information,
corresponding to the name argument to LoadLocation or FixedZone.`}
	Timer_methods["Stop"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "bool", Doc: `Stop prevents the Timer from firing.
It returns true if the call stops the timer, false if the timer has already
expired or been stopped.
Stop does not close the channel, to prevent a read from the channel succeeding
incorrectly.

To ensure the channel is empty after a call to Stop, check the
return value and drain the channel.
For example, assuming the program has not received from t.C already:

	if !t.Stop() {
		<-t.C
	}

This cannot be done concurrent to other receives from the Timer's
channel or other calls to the Timer's Stop method.

For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer
has already expired and the function f has been started in its own goroutine;
Stop does not wait for f to complete before returning.
If the caller needs to know whether f is completed, it must coordinate
with f explicitly.`}
	Timer_methods["Reset"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "bool", Doc: `Reset changes the timer to expire after duration d.
It returns true if the timer had been active, false if the timer had
expired or been stopped.

For a Timer created with NewTimer, Reset should be invoked only on
stopped or expired timers with drained channels.

If a program has already received a value from t.C, the timer is known
to have expired and the channel drained, so t.Reset can be used directly.
If a program has not yet received a value from t.C, however,
the timer must be stopped and—if Stop reports that the timer expired
before being stopped—the channel explicitly drained:

	if !t.Stop() {
		<-t.C
	}
	t.Reset(d)

This should not be done concurrent to other receives from the Timer's
channel.

Note that it is not possible to use Reset's return value correctly, as there
is a race condition between draining the channel and the new timer expiring.
Reset should always be invoked on stopped or expired channels, as described above.
The return value exists to preserve compatibility with existing programs.

For a Timer created with AfterFunc(d, f), Reset either reschedules
when f will run, in which case Reset returns true, or schedules f
to run again, in which case it returns false.
When Reset returns false, Reset neither waits for the prior f to
complete before returning nor does it guarantee that the subsequent
goroutine running f does not run concurrently with the prior
one. If the caller needs to know whether the prior execution of
f is completed, it must coordinate with f explicitly.`}
	pkgreflect.AddPackage("time", &pkgreflect.Package{
		Types: map[string]pkgreflect.Type{
			"Duration":   {Doc: ``, Value: reflect.TypeOf((*Duration)(nil)).Elem(), Methods: Duration_methods},
			"Location":   {Doc: ``, Value: reflect.TypeOf((*Location)(nil)).Elem(), Methods: Location_methods},
			"Month":      {Doc: ``, Value: reflect.TypeOf((*Month)(nil)).Elem(), Methods: Month_methods},
			"ParseError": {Doc: ``, Value: reflect.TypeOf((*ParseError)(nil)).Elem(), Methods: ParseError_methods},
			"Ticker":     {Doc: ``, Value: reflect.TypeOf((*Ticker)(nil)).Elem(), Methods: Ticker_methods},
			"Time":       {Doc: ``, Value: reflect.TypeOf((*Time)(nil)).Elem(), Methods: Time_methods},
			"Timer":      {Doc: ``, Value: reflect.TypeOf((*Timer)(nil)).Elem(), Methods: Timer_methods},
			"Weekday":    {Doc: ``, Value: reflect.TypeOf((*Weekday)(nil)).Elem(), Methods: Weekday_methods},
		},

		Functions: map[string]pkgreflect.FuncValue{
			"After": {Doc: `After waits for the duration to elapse and then sends the current time
on the returned channel.
It is equivalent to NewTimer(d).C.
The underlying Timer is not recovered by the garbage collector
until the timer fires. If efficiency is a concern, use NewTimer
instead and call Timer.Stop if the timer is no longer needed.`, Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Unknown", Value: reflect.ValueOf(After)},

			"AfterFunc": {Doc: `AfterFunc waits for the duration to elapse and then calls f
in its own goroutine. It returns a Timer that can
be used to cancel the call using its Stop method.
The returned Timer's C field is not used and will be nil.`, Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}, {Name: "f", Tag: "Unknown"}}, Tag: "Timer", Value: reflect.ValueOf(AfterFunc)},

			"Date": {Doc: `Date returns the Time corresponding to

	yyyy-mm-dd hh:mm:ss + nsec nanoseconds

in the appropriate zone for that time in the given location.

The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.

A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice. In such cases, the
choice of time zone, and therefore the time, is not well-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.

Date panics if loc is nil.`, Args: []pkgreflect.Arg{{Name: "year", Tag: "int"}, {Name: "month", Tag: "Month"}, {Name: "day", Tag: "int"}, {Name: "hour", Tag: "int"}, {Name: "min", Tag: "int"}, {Name: "sec", Tag: "int"}, {Name: "nsec", Tag: "int"}, {Name: "loc", Tag: "Location"}}, Tag: "Time", Value: reflect.ValueOf(Date)},

			"FixedZone": {Doc: `FixedZone returns a Location that always uses
the given zone name and offset (seconds east of UTC).`, Args: []pkgreflect.Arg{{Name: "name", Tag: "string"}, {Name: "offset", Tag: "int"}}, Tag: "Location", Value: reflect.ValueOf(FixedZone)},

			"LoadLocation": {Doc: `LoadLocation returns the Location with the given name.

If the name is "" or "UTC", LoadLocation returns UTC.
If the name is "Local", LoadLocation returns Local.

Otherwise, the name is taken to be a location name corresponding to a file
in the IANA Time Zone database, such as "America/New_York".

LoadLocation looks for the IANA Time Zone database in the following
locations in order:

  - the directory or uncompressed zip file named by the ZONEINFO environment variable
  - on a Unix system, the system standard installation location
  - $GOROOT/lib/time/zoneinfo.zip
  - the time/tzdata package, if it was imported`, Args: []pkgreflect.Arg{{Name: "name", Tag: "string"}}, Tag: "any", Value: reflect.ValueOf(LoadLocation)},

			"LoadLocationFromTZData": {Doc: `LoadLocationFromTZData returns a Location with the given name
initialized from the IANA Time Zone database-formatted data.
The data should be in the format of a standard IANA time zone file
(for example, the content of /etc/localtime on Unix systems).`, Args: []pkgreflect.Arg{{Name: "name", Tag: "string"}, {Name: "data", Tag: "[]byte"}}, Tag: "any", Value: reflect.ValueOf(LoadLocationFromTZData)},

			"NewTicker": {Doc: `NewTicker returns a new Ticker containing a channel that will send
the current time on the channel after each tick. The period of the
ticks is specified by the duration argument. The ticker will adjust
the time interval or drop ticks to make up for slow receivers.
The duration d must be greater than zero; if not, NewTicker will
panic. Stop the ticker to release associated resources.`, Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Ticker", Value: reflect.ValueOf(NewTicker)},

			"NewTimer": {Doc: `NewTimer creates a new Timer that will send
the current time on its channel after at least duration d.`, Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Timer", Value: reflect.ValueOf(NewTimer)},

			"Now": {Doc: `Now returns the current local time.`, Args: []pkgreflect.Arg{}, Tag: "Time", Value: reflect.ValueOf(Now)},

			"Parse": {Doc: `Parse parses a formatted string and returns the time value it represents.
See the documentation for the constant called Layout to see how to
represent the format. The second argument must be parseable using
the format string (layout) provided as the first argument.

The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.

When parsing (only), the input may contain a fractional second
field immediately after the seconds field, even if the layout does not
signify its presence. In that case either a comma or a decimal point
followed by a maximal series of digits is parsed as a fractional second.
Fractional seconds are truncated to nanosecond precision.

Elements omitted from the layout are assumed to be zero or, when
zero is impossible, one, so parsing "3:04pm" returns the time
corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
0, this time is before the zero Time).
Years must be in the range 0000..9999. The day of the week is checked
for syntax but it is otherwise ignored.

For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
as 19NN and a value NN < 69 will be treated as 20NN.

The remainder of this comment describes the handling of time zones.

In the absence of a time zone indicator, Parse returns a time in UTC.

When parsing a time with a zone offset like -0700, if the offset corresponds
to a time zone used by the current location (Local), then Parse uses that
location and zone in the returned time. Otherwise it records the time as
being in a fabricated location with time fixed at the given zone offset.

When parsing a time with a zone abbreviation like MST, if the zone abbreviation
has a defined offset in the current location, then that offset is used.
The zone abbreviation "UTC" is recognized as UTC regardless of location.
If the zone abbreviation is unknown, Parse records the time as being
in a fabricated location with the given zone abbreviation and a zero offset.
This choice means that such a time can be parsed and reformatted with the
same layout losslessly, but the exact instant used in the representation will
differ by the actual zone offset. To avoid such problems, prefer time layouts
that use a numeric zone offset, or use ParseInLocation.`, Args: []pkgreflect.Arg{{Name: "layout", Tag: "string"}, {Name: "value", Tag: "string"}}, Tag: "any", Value: reflect.ValueOf(Parse)},

			"ParseDuration": {Doc: `ParseDuration parses a duration string.
A duration string is a possibly signed sequence of
decimal numbers, each with optional fraction and a unit suffix,
such as "300ms", "-1.5h" or "2h45m".
Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".`, Args: []pkgreflect.Arg{{Name: "s", Tag: "string"}}, Tag: "any", Value: reflect.ValueOf(ParseDuration)},

			"ParseInLocation": {Doc: `ParseInLocation is like Parse but differs in two important ways.
First, in the absence of time zone information, Parse interprets a time as UTC;
ParseInLocation interprets the time as in the given location.
Second, when given a zone offset or abbreviation, Parse tries to match it
against the Local location; ParseInLocation uses the given location.`, Args: []pkgreflect.Arg{{Name: "layout", Tag: "string"}, {Name: "value", Tag: "string"}, {Name: "loc", Tag: "Location"}}, Tag: "any", Value: reflect.ValueOf(ParseInLocation)},

			"Since": {Doc: `Since returns the time elapsed since t.
It is shorthand for time.Now().Sub(t).`, Args: []pkgreflect.Arg{{Name: "t", Tag: "Time"}}, Tag: "Duration", Value: reflect.ValueOf(Since)},

			"Sleep": {Doc: `Sleep pauses the current goroutine for at least the duration d.
A negative or zero duration causes Sleep to return immediately.`, Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "any", Value: reflect.ValueOf(Sleep)},

			"Tick": {Doc: `Tick is a convenience wrapper for NewTicker providing access to the ticking
channel only. While Tick is useful for clients that have no need to shut down
the Ticker, be aware that without a way to shut it down the underlying
Ticker cannot be recovered by the garbage collector; it "leaks".
Unlike NewTicker, Tick will return nil if d <= 0.`, Args: []pkgreflect.Arg{{Name: "d", Tag: "Duration"}}, Tag: "Unknown", Value: reflect.ValueOf(Tick)},

			"Unix": {Doc: `Unix returns the local Time corresponding to the given Unix time,
sec seconds and nsec nanoseconds since January 1, 1970 UTC.
It is valid to pass nsec outside the range [0, 999999999].
Not all sec values have a corresponding time value. One such
value is 1<<63-1 (the largest int64 value).`, Args: []pkgreflect.Arg{{Name: "sec", Tag: "int64"}, {Name: "nsec", Tag: "int64"}}, Tag: "Time", Value: reflect.ValueOf(Unix)},

			"UnixMicro": {Doc: `UnixMicro returns the local Time corresponding to the given Unix time,
usec microseconds since January 1, 1970 UTC.`, Args: []pkgreflect.Arg{{Name: "usec", Tag: "int64"}}, Tag: "Time", Value: reflect.ValueOf(UnixMicro)},

			"UnixMilli": {Doc: `UnixMilli returns the local Time corresponding to the given Unix time,
msec milliseconds since January 1, 1970 UTC.`, Args: []pkgreflect.Arg{{Name: "msec", Tag: "int64"}}, Tag: "Time", Value: reflect.ValueOf(UnixMilli)},

			"Until": {Doc: `Until returns the duration until t.
It is shorthand for t.Sub(time.Now()).`, Args: []pkgreflect.Arg{{Name: "t", Tag: "Time"}}, Tag: "Duration", Value: reflect.ValueOf(Until)},
		},

		Variables: map[string]pkgreflect.Value{
			"Local": {Doc: ``, Value: reflect.ValueOf(&Local)},
			"UTC":   {Doc: ``, Value: reflect.ValueOf(&UTC)},
		},

		Consts: map[string]pkgreflect.Value{
			"ANSIC":       {Doc: ``, Value: reflect.ValueOf(ANSIC)},
			"April":       {Doc: ``, Value: reflect.ValueOf(April)},
			"August":      {Doc: ``, Value: reflect.ValueOf(August)},
			"DateOnly":    {Doc: ``, Value: reflect.ValueOf(DateOnly)},
			"DateTime":    {Doc: ``, Value: reflect.ValueOf(DateTime)},
			"December":    {Doc: ``, Value: reflect.ValueOf(December)},
			"February":    {Doc: ``, Value: reflect.ValueOf(February)},
			"Friday":      {Doc: ``, Value: reflect.ValueOf(Friday)},
			"Hour":        {Doc: ``, Value: reflect.ValueOf(Hour)},
			"January":     {Doc: ``, Value: reflect.ValueOf(January)},
			"July":        {Doc: ``, Value: reflect.ValueOf(July)},
			"June":        {Doc: ``, Value: reflect.ValueOf(June)},
			"Kitchen":     {Doc: ``, Value: reflect.ValueOf(Kitchen)},
			"Layout":      {Doc: ``, Value: reflect.ValueOf(Layout)},
			"March":       {Doc: ``, Value: reflect.ValueOf(March)},
			"May":         {Doc: ``, Value: reflect.ValueOf(May)},
			"Microsecond": {Doc: ``, Value: reflect.ValueOf(Microsecond)},
			"Millisecond": {Doc: ``, Value: reflect.ValueOf(Millisecond)},
			"Minute":      {Doc: ``, Value: reflect.ValueOf(Minute)},
			"Monday":      {Doc: ``, Value: reflect.ValueOf(Monday)},
			"Nanosecond":  {Doc: ``, Value: reflect.ValueOf(Nanosecond)},
			"November":    {Doc: ``, Value: reflect.ValueOf(November)},
			"October":     {Doc: ``, Value: reflect.ValueOf(October)},
			"RFC1123":     {Doc: ``, Value: reflect.ValueOf(RFC1123)},
			"RFC1123Z":    {Doc: ``, Value: reflect.ValueOf(RFC1123Z)},
			"RFC3339":     {Doc: ``, Value: reflect.ValueOf(RFC3339)},
			"RFC3339Nano": {Doc: ``, Value: reflect.ValueOf(RFC3339Nano)},
			"RFC822":      {Doc: ``, Value: reflect.ValueOf(RFC822)},
			"RFC822Z":     {Doc: ``, Value: reflect.ValueOf(RFC822Z)},
			"RFC850":      {Doc: ``, Value: reflect.ValueOf(RFC850)},
			"RubyDate":    {Doc: ``, Value: reflect.ValueOf(RubyDate)},
			"Saturday":    {Doc: ``, Value: reflect.ValueOf(Saturday)},
			"Second":      {Doc: ``, Value: reflect.ValueOf(Second)},
			"September":   {Doc: ``, Value: reflect.ValueOf(September)},
			"Stamp":       {Doc: `Handy time stamps.`, Value: reflect.ValueOf(Stamp)},
			"StampMicro":  {Doc: ``, Value: reflect.ValueOf(StampMicro)},
			"StampMilli":  {Doc: ``, Value: reflect.ValueOf(StampMilli)},
			"StampNano":   {Doc: ``, Value: reflect.ValueOf(StampNano)},
			"Sunday":      {Doc: ``, Value: reflect.ValueOf(Sunday)},
			"Thursday":    {Doc: ``, Value: reflect.ValueOf(Thursday)},
			"TimeOnly":    {Doc: ``, Value: reflect.ValueOf(TimeOnly)},
			"Tuesday":     {Doc: ``, Value: reflect.ValueOf(Tuesday)},
			"UnixDate":    {Doc: ``, Value: reflect.ValueOf(UnixDate)},
			"Wednesday":   {Doc: ``, Value: reflect.ValueOf(Wednesday)},
		},
	})
}
