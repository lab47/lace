// Code generated by github.com/lab47/lace/pkg/pkgreflect DO NOT EDIT.
package reflect

import "reflect"
import "github.com/lab47/lace/pkg/pkgreflect"
import . "github.com/vektra/tai64n"

func init() {
	TAI64N_methods := map[string]pkgreflect.Func{}
	LeapMoment_methods := map[string]pkgreflect.Func{}
	LeapSecond_methods := map[string]pkgreflect.Func{}
	TimeComparison_methods := map[string]pkgreflect.Func{}
	TAI64N_methods["Time"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "time.Time", Doc: `Convert back to a time.Time`}
	TAI64N_methods["WriteStorage"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "buf", Tag: "[]byte"}}, Tag: "any", Doc: `Return the value in it's canonical binary format`}
	TAI64N_methods["ReadStorage"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "buf", Tag: "[]byte"}}, Tag: "any", Doc: `Update the value from it's canonical binary format`}
	TAI64N_methods["Label"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `Render the moment in the canonical ascii format`}
	TAI64N_methods["MarshalJSON"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: ``}
	TAI64N_methods["UnmarshalJSON"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "error", Doc: ``}
	TAI64N_methods["Before"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "other", Tag: "TAI64N"}}, Tag: "bool", Doc: `Indicated if the called moment is before the argument`}
	TAI64N_methods["After"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "other", Tag: "TAI64N"}}, Tag: "bool", Doc: `Indicated if the called moment is after the argument`}
	TAI64N_methods["Compare"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "other", Tag: "TAI64N"}}, Tag: "TimeComparison", Doc: `Indicate how the 2 moments compare to eachother`}
	TAI64N_methods["Add"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "dur", Tag: "time.Duration"}}, Tag: "TAI64N", Doc: `Generate a new moment by adding a duration`}
	TAI64N_methods["Sub"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "other", Tag: "TAI64N"}}, Tag: "time.Duration", Doc: `Return a duration as the difference between the 2 times`}
	TAI64N_methods["Reset"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: ``}
	TAI64N_methods["ProtoMessage"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: ``}
	TAI64N_methods["Descriptor"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: ``}
	TAI64N_methods["Equal"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "that", Tag: "any"}}, Tag: "bool", Doc: ``}
	TAI64N_methods["GoString"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: ``}
	TAI64N_methods["Marshal"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: ``}
	TAI64N_methods["MarshalTo"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "any", Doc: ``}
	TAI64N_methods["Size"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: ``}
	TAI64N_methods["Unmarshal"] = pkgreflect.Func{Args: []pkgreflect.Arg{{Name: "data", Tag: "[]byte"}}, Tag: "error", Doc: ``}
	TAI64N_methods["Date"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "any", Doc: `Calculate the year, month, and day of this moment. If the moment
falls on a leap second, the displayed value will be that of the
leap second as the 60th second of the day.`}
	TAI64N_methods["Clock"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "int", Doc: `Calculate the hour, minute, and second of this moment. If the moment
falls on a leap second, the displayed value will be that of the
leap second as the 60th second of the day.`}
	TAI64N_methods["String"] = pkgreflect.Func{Args: []pkgreflect.Arg{}, Tag: "string", Doc: `Render the moment as a RFC3339Nano format`}
	pkgreflect.AddPackage("github.com/vektra/tai64n", &pkgreflect.Package{
		Types: map[string]pkgreflect.Type{
			"LeapMoment":     {Doc: ``, Value: reflect.TypeOf((*LeapMoment)(nil)).Elem(), Methods: LeapMoment_methods},
			"LeapSecond":     {Doc: ``, Value: reflect.TypeOf((*LeapSecond)(nil)).Elem(), Methods: LeapSecond_methods},
			"TAI64N":         {Doc: ``, Value: reflect.TypeOf((*TAI64N)(nil)).Elem(), Methods: TAI64N_methods},
			"TimeComparison": {Doc: ``, Value: reflect.TypeOf((*TimeComparison)(nil)).Elem(), Methods: TimeComparison_methods},
		},

		Functions: map[string]pkgreflect.FuncValue{
			"FromTime": {Doc: `Convert from a time.Time`, Args: []pkgreflect.Arg{{Name: "t", Tag: "time.Time"}}, Tag: "any", Value: reflect.ValueOf(FromTime)},

			"LeapSecondsInvolved": {Doc: `Return the number of leap seconds that occur previous to the given
time.`, Args: []pkgreflect.Arg{{Name: "t", Tag: "time.Time"}}, Tag: "any", Value: reflect.ValueOf(LeapSecondsInvolved)},

			"Now": {Doc: `Return the current moment`, Args: []pkgreflect.Arg{}, Tag: "any", Value: reflect.ValueOf(Now)},

			"ParseTAI64NLabel": {Doc: `Parse the canonical ascii format`, Args: []pkgreflect.Arg{{Name: "label", Tag: "string"}}, Tag: "any", Value: reflect.ValueOf(ParseTAI64NLabel)},
		},

		Variables: map[string]pkgreflect.Value{
			"AllLeapMoments":         {Doc: ``, Value: reflect.ValueOf(&AllLeapMoments)},
			"AllLeapSeconds":         {Doc: ``, Value: reflect.ValueOf(&AllLeapSeconds)},
			"ErrIntOverflowTai64N":   {Doc: ``, Value: reflect.ValueOf(&ErrIntOverflowTai64N)},
			"ErrInvalidLengthTai64N": {Doc: ``, Value: reflect.ValueOf(&ErrInvalidLengthTai64N)},
		},

		Consts: map[string]pkgreflect.Value{
			"After":             {Doc: ``, Value: reflect.ValueOf(After)},
			"Before":            {Doc: ``, Value: reflect.ValueOf(Before)},
			"Equal":             {Doc: ``, Value: reflect.ValueOf(Equal)},
			"TAI64OriginalBase": {Doc: ``, Value: reflect.ValueOf(TAI64OriginalBase)},
		},
	})
}
