// This file is generated by generate-std.clj script. Do not edit manually!

package filepath

import (
	. "github.com/lab47/lace/core"
	"path/filepath"
)

var list_separator_ String
var separator_ String
var __abs__P ProcFn = __abs_
var abs_ Proc = Proc{Fn: __abs__P, Name: "abs_", Package: "std/filepath"}

func __abs_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Abs(path)
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __isabs__P ProcFn = __isabs_
var isabs_ Proc = Proc{Fn: __isabs__P, Name: "isabs_", Package: "std/filepath"}

func __isabs_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.IsAbs(path), nil
		return MakeBoolean(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __base__P ProcFn = __base_
var base_ Proc = Proc{Fn: __base__P, Name: "base_", Package: "std/filepath"}

func __base_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Base(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __clean__P ProcFn = __clean_
var clean_ Proc = Proc{Fn: __clean__P, Name: "clean_", Package: "std/filepath"}

func __clean_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Clean(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __dir__P ProcFn = __dir_
var dir_ Proc = Proc{Fn: __dir__P, Name: "dir_", Package: "std/filepath"}

func __dir_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Dir(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __eval_symlinks__P ProcFn = __eval_symlinks_
var eval_symlinks_ Proc = Proc{Fn: __eval_symlinks__P, Name: "eval_symlinks_", Package: "std/filepath"}

func __eval_symlinks_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.EvalSymlinks(path)
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __ext__P ProcFn = __ext_
var ext_ Proc = Proc{Fn: __ext__P, Name: "ext_", Package: "std/filepath"}

func __ext_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Ext(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __file_seq__P ProcFn = __file_seq_
var file_seq_ Proc = Proc{Fn: __file_seq__P, Name: "file_seq_", Package: "std/filepath"}

func __file_seq_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		root, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := fileSeq(root)
		return _res, err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __from_slash__P ProcFn = __from_slash_
var from_slash_ Proc = Proc{Fn: __from_slash__P, Name: "from_slash_", Package: "std/filepath"}

func __from_slash_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.FromSlash(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __glob__P ProcFn = __glob_
var glob_ Proc = Proc{Fn: __glob__P, Name: "glob_", Package: "std/filepath"}

func __glob_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		pattern, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Glob(pattern)
		return MakeStringVector(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __join__P ProcFn = __join_
var join_ Proc = Proc{Fn: __join__P, Name: "join_", Package: "std/filepath"}

func __join_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case true:
		var err error
		if err := CheckArity(_env, _args, 0, 999); err != nil { return nil, err }
		elems, err := ExtractStrings(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.Join(elems...), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __ismatches__P ProcFn = __ismatches_
var ismatches_ Proc = Proc{Fn: __ismatches__P, Name: "ismatches_", Package: "std/filepath"}

func __ismatches_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 2:
		var err error
		pattern, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		name, err := ExtractString(_env, _args, 1); if err != nil { return nil, err }
		_res, err := filepath.Match(pattern, name)
		return MakeBoolean(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __rel__P ProcFn = __rel_
var rel_ Proc = Proc{Fn: __rel__P, Name: "rel_", Package: "std/filepath"}

func __rel_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 2:
		var err error
		basepath, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		targpath, err := ExtractString(_env, _args, 1); if err != nil { return nil, err }
		_res, err := filepath.Rel(basepath, targpath)
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __split__P ProcFn = __split_
var split_ Proc = Proc{Fn: __split__P, Name: "split_", Package: "std/filepath"}

func __split_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		 _dir, _file := filepath.Split(path)
		_res := NewVectorFrom(MakeString(_dir), MakeString(_file))
		return _res, err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __split_list__P ProcFn = __split_list_
var split_list_ Proc = Proc{Fn: __split_list__P, Name: "split_list_", Package: "std/filepath"}

func __split_list_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.SplitList(path), nil
		return MakeStringVector(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __to_slash__P ProcFn = __to_slash_
var to_slash_ Proc = Proc{Fn: __to_slash__P, Name: "to_slash_", Package: "std/filepath"}

func __to_slash_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.ToSlash(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

var __volume_name__P ProcFn = __volume_name_
var volume_name_ Proc = Proc{Fn: __volume_name__P, Name: "volume_name_", Package: "std/filepath"}

func __volume_name_(_env *Env, _args []Object) (Object, error) {
	_c := len(_args)
	switch {
	case _c == 1:
		var err error
		path, err := ExtractString(_env, _args, 0); if err != nil { return nil, err }
		_res, err := filepath.VolumeName(path), nil
		return MakeString(_res), err

	default:
		return nil, ErrorArity(_env, _c)
	}
}

func Init(env *Env, ns *Namespace) {
	list_separator_ = MakeString(string(filepath.ListSeparator))
	separator_ = MakeString(string(filepath.Separator))
	InternsOrThunks(env, ns)
}

func init() {
	AddNativeNamespace("lace.filepath", func(env *Env) error {
		ns := env.EnsureNamespace(MakeSymbol("lace.filepath"))
		Init(env, ns)
		return nil
	})
}
